<!--
001. useState
1-1. State는 컴포넌트가 가질 수 있는 상태를 말한다.
1-2. import { useState } from 'react';
>>> state를 간편하게 생성하고 업데이트를 시킬 수 있게 해주는 도구임으로
    사용하기 위해서는 꼭 import해야한다.
1-3. const [state, setState] = useState(초기값);
>>> 생성과 동시에 가져야 할 초기값을 지정해준다.
    첫번째 요소인 state는 데이터, 두번째 요소인 setState는 데이터를 수정하기 위한 함수이다.
ex) 로딩을 기준으로 한다면, let [loading, setLoading] = useState(true);
    만약 변수를 재선언해서 값을 변경한다면 두번째 요소인 setLoading을 선언해주면 된다.
    setState(1); // state의 값을 1로 변경
    const [time, setTime] = useState(1);
    const onClick = () => {
        setTime(time + 1);
    }
    console.log('time 업데이트 -> ', time);
    return (
        <div className="App">
        <header className="App-header">
            <span>현재시간: {time}시</span>
            // 클릭했을 시 1씩 증가
            <button onClick={onClick}>update</button>
        </header>
     </div>

002. useEffect
1-1 useEffect는 렌더링 될때마다 특정 작업을 실행할 수 있도록 한다.





003. async/await/fetch
async/await:

async/await는 비동기 코드를 작성하고 관리하기 위한 JavaScript의 키워드입니다.
async 함수는 항상 Promise를 반환하며, 비동기 작업을 수행하는 중간 결과를 간단하게 처리할 수 있도록 해줍니다.
await 키워드는 async 함수 내에서만 사용할 수 있으며, 비동기 작업이 완료될 때까지 코드 실행을 일시 중지합니다.
await 키워드 뒤에는 Promise를 반환하는 비동기 함수, Promise 객체, 또는 다른 값이 올 수 있습니다.
await 키워드를 사용하면 비동기 작업의 결과를 받을 수 있고, 이를 변수에 할당하여 다음 작업에 활용할 수 있습니다.
async/await는 기존의 콜백 함수나 Promise 체인을 사용한 비동기 코드보다 가독성이 높고, 디버깅이 쉬워 코드의 유지 보수성을 높여줍니다.

async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.log(error);
  }
}

fetch:

fetch는 네트워크를 통해 리소스를 가져오기 위한 JavaScript의 API입니다.
fetch 함수는 Promise를 반환하며, 비동기적으로 HTTP 요청을 보내고 응답을 처리할 수 있습니다.
fetch 함수는 주로 HTTP GET 요청을 수행하지만, 다른 HTTP 메서드(POST, PUT, DELETE 등)도 사용할 수 있습니다.
fetch 함수는 URL을 인자로 받고, 해당 URL에 HTTP 요청을 보냅니다.
응답으로 받은 데이터는 Promise를 통해 처리되며, JSON 데이터를 받을 때는 response.json()을 호출하여 JSON 형식의 데이터를 추출할 수 있습니다.
fetch 함수를 사용하면 비동기적으로 데이터를 가져올 수 있고, 이를 활용하여 웹 애플리케이션에서 서버와 통신하는 데 사용할 수 있습니다.

fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.log(error));

004. import React from 'react';/import ReactDom from 'react-dom';

import React from 'react';
React 라이브러리에서 React 모듈을 가져오는 역할을 합니다. React를 사용하여 컴포넌트를 작성하고 애플리케이션을 구축할 때 항상 이러한 형태로 React를 가져와야 합니다.
React 라이브러리에서 제공하는 기능을 사용하기 위한 객체입니다. React 라이브러리는 React 엘리먼트를 생성하고 조작하는 데 필요한 함수와 컴포넌트를 포함하고 있습니다.

import ReactDom from 'react-dom';
ReactDOM.render(element, container[, callback]) 함수:
element: 화면에 렌더링할 React 엘리먼트입니다.
container: React 엘리먼트를 렌더링할 DOM 컨테이너 엘리먼트입니다.
callback (선택 사항): 렌더링 작업이 완료된 후 호출될 콜백 함수입니다.
ReactDOM.render 함수는 React 엘리먼트를 실제 DOM에 렌더링하는 역할을 합니다. React 엘리먼트를 DOM 컨테이너에 삽입하여 실제 화면에 보여주는 역할을 수행합니다.
<<<index.js>>>
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(
    <App />,
    document.getElementById('root')
);

<<<App.js>>>
function App() {
    return ( <h2>Test</h2> );
}
export default App;

005.import {BrowserRouter as Router, Route, Routes, Link, BrowserRouter} from "react-router-dom";
5버전에서 6버전으로 변경되면서 Switch 대신 Routes로 변경

Router: React 애플리케이션의 최상위 라우팅 컴포넌트입니다. 라우터 컴포넌트는 URL 경로와 매칭되는 컴포넌트를 렌더링하고, 브라우저의 주소 히스토리 관리를 담당합니다.
Route: 특정 URL 경로와 매칭되는 컴포넌트를 렌더링하는 역할을 합니다. 여러 개의 Route 컴포넌트를 사용하여 서로 다른 URL 경로에 대한 렌더링 규칙을 지정할 수 있습니다.
Routes: Route 컴포넌트를 그룹화하고, 중첩된 라우팅을 구현할 때 사용합니다. Routes 컴포넌트는 여러 개의 Route 컴포넌트를 포함하고, 경로에 따라 적절한 컴포넌트를 렌더링합니다.
Link: 클릭할 수 있는 링크를 생성하는 역할을 합니다. Link 컴포넌트는 사용자가 클릭하면 해당 URL로 이동하도록 동작하며, 애플리케이션 내부에서 페이지 전환을 처리하는 데 사용됩니다.
BrowserRouter: HTML5의 브라우저 히스토리 API를 사용하여 라우팅을 처리하는 컴포넌트입니다. BrowserRouter 컴포넌트는 애플리케이션을 브라우저의 실제 URL 경로와 연결합니다.

function App() {
    return (
        <Router>
            <Routes>
                <Route path="/hello" element={<h1>Hello</h1>} />
                <Route path="/movie/:id" element={<Detail />} />
                <Route path={`${process.env.PUBLIC_URL}/`} element={<Home />} />
                `${process.env.PUBLIC_URL}/` >>> 정적 리소스에 접근하기 위해 사용되는 환경 변수
            </Routes>
        </Router>
    );
}




-->